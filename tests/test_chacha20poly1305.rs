extern crate hacspec;
use hacspec::*;
hacspec_imports!();

extern crate hacspecs;
use hacspecs::{chacha20::*, chacha20poly1305, poly1305::*};

#[test]
fn kat_test() {
    let k = Key([
        U8(0x80), U8(0x81), U8(0x82), U8(0x83), U8(0x84), U8(0x85), U8(0x86), U8(0x87), U8(0x88),
        U8(0x89), U8(0x8a), U8(0x8b), U8(0x8c), U8(0x8d), U8(0x8e), U8(0x8f), U8(0x90), U8(0x91),
        U8(0x92), U8(0x93), U8(0x94), U8(0x95), U8(0x96), U8(0x97), U8(0x98), U8(0x99), U8(0x9a),
        U8(0x9b), U8(0x9c), U8(0x9d), U8(0x9e), U8(0x9f),
    ]);
    let iv = IV([
        U8(0x07), U8(0x00), U8(0x00), U8(0x00), U8(0x40), U8(0x41), U8(0x42), U8(0x43), U8(0x44),
        U8(0x45), U8(0x46), U8(0x47),
    ]);
    let msg = Bytes::from_array(&[
        U8(0x4c), U8(0x61), U8(0x64), U8(0x69), U8(0x65), U8(0x73), U8(0x20), U8(0x61), U8(0x6e),
        U8(0x64), U8(0x20), U8(0x47), U8(0x65), U8(0x6e), U8(0x74), U8(0x6c), U8(0x65), U8(0x6d),
        U8(0x65), U8(0x6e), U8(0x20), U8(0x6f), U8(0x66), U8(0x20), U8(0x74), U8(0x68), U8(0x65),
        U8(0x20), U8(0x63), U8(0x6c), U8(0x61), U8(0x73), U8(0x73), U8(0x20), U8(0x6f), U8(0x66),
        U8(0x20), U8(0x27), U8(0x39), U8(0x39), U8(0x3a), U8(0x20), U8(0x49), U8(0x66), U8(0x20),
        U8(0x49), U8(0x20), U8(0x63), U8(0x6f), U8(0x75), U8(0x6c), U8(0x64), U8(0x20), U8(0x6f),
        U8(0x66), U8(0x66), U8(0x65), U8(0x72), U8(0x20), U8(0x79), U8(0x6f), U8(0x75), U8(0x20),
        U8(0x6f), U8(0x6e), U8(0x6c), U8(0x79), U8(0x20), U8(0x6f), U8(0x6e), U8(0x65), U8(0x20),
        U8(0x74), U8(0x69), U8(0x70), U8(0x20), U8(0x66), U8(0x6f), U8(0x72), U8(0x20), U8(0x74),
        U8(0x68), U8(0x65), U8(0x20), U8(0x66), U8(0x75), U8(0x74), U8(0x75), U8(0x72), U8(0x65),
        U8(0x2c), U8(0x20), U8(0x73), U8(0x75), U8(0x6e), U8(0x73), U8(0x63), U8(0x72), U8(0x65),
        U8(0x65), U8(0x6e), U8(0x20), U8(0x77), U8(0x6f), U8(0x75), U8(0x6c), U8(0x64), U8(0x20),
        U8(0x62), U8(0x65), U8(0x20), U8(0x69), U8(0x74), U8(0x2e),
    ]);
    let aad = Bytes::from_array(&[
        U8(0x50), U8(0x51), U8(0x52), U8(0x53), U8(0xc0), U8(0xc1), U8(0xc2), U8(0xc3), U8(0xc4),
        U8(0xc5), U8(0xc6), U8(0xc7),
    ]);
    let exp_cipher = Bytes::from_array(&[
        U8(0xd3), U8(0x1a), U8(0x8d), U8(0x34), U8(0x64), U8(0x8e), U8(0x60), U8(0xdb), U8(0x7b),
        U8(0x86), U8(0xaf), U8(0xbc), U8(0x53), U8(0xef), U8(0x7e), U8(0xc2), U8(0xa4), U8(0xad),
        U8(0xed), U8(0x51), U8(0x29), U8(0x6e), U8(0x08), U8(0xfe), U8(0xa9), U8(0xe2), U8(0xb5),
        U8(0xa7), U8(0x36), U8(0xee), U8(0x62), U8(0xd6), U8(0x3d), U8(0xbe), U8(0xa4), U8(0x5e),
        U8(0x8c), U8(0xa9), U8(0x67), U8(0x12), U8(0x82), U8(0xfa), U8(0xfb), U8(0x69), U8(0xda),
        U8(0x92), U8(0x72), U8(0x8b), U8(0x1a), U8(0x71), U8(0xde), U8(0x0a), U8(0x9e), U8(0x06),
        U8(0x0b), U8(0x29), U8(0x05), U8(0xd6), U8(0xa5), U8(0xb6), U8(0x7e), U8(0xcd), U8(0x3b),
        U8(0x36), U8(0x92), U8(0xdd), U8(0xbd), U8(0x7f), U8(0x2d), U8(0x77), U8(0x8b), U8(0x8c),
        U8(0x98), U8(0x03), U8(0xae), U8(0xe3), U8(0x28), U8(0x09), U8(0x1b), U8(0x58), U8(0xfa),
        U8(0xb3), U8(0x24), U8(0xe4), U8(0xfa), U8(0xd6), U8(0x75), U8(0x94), U8(0x55), U8(0x85),
        U8(0x80), U8(0x8b), U8(0x48), U8(0x31), U8(0xd7), U8(0xbc), U8(0x3f), U8(0xf4), U8(0xde),
        U8(0xf0), U8(0x8e), U8(0x4b), U8(0x7a), U8(0x9d), U8(0xe5), U8(0x76), U8(0xd2), U8(0x65),
        U8(0x86), U8(0xce), U8(0xc6), U8(0x4b), U8(0x61), U8(0x16),
    ]);
    let exp_mac = Tag([
        U8(0x1a), U8(0xe1), U8(0x0b), U8(0x59), U8(0x4f), U8(0x09), U8(0xe2), U8(0x6a), U8(0x7e),
        U8(0x90), U8(0x2e), U8(0xcb), U8(0xd0), U8(0x60), U8(0x06), U8(0x91),
    ]);
    let (cipher, mac) = chacha20poly1305::encrypt(k, iv, aad.clone(), msg.clone()).unwrap();
    assert_eq!(
        exp_cipher.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        cipher.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
    assert_eq!(
        exp_mac.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        mac.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
    let decrypted_msg = chacha20poly1305::decrypt(k, iv, aad, cipher, mac).unwrap();
    assert_eq!(
        msg.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        decrypted_msg.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
}
