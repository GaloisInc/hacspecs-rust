extern crate hacspec;
use hacspec::*;
hacspec_imports!();

extern crate hacspecs;
use hacspecs::aes::*;

fn enc_dec_test(m: Bytes, key: Key, iv: Nonce, ctr: U32, ctxt: Option<Bytes>) {
    let c = aes128_encrypt(key, iv, ctr, m.clone());
    let m_dec = aes128_decrypt(key, iv, ctr, c.clone());
    assert_eq!(
        m.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        m_dec.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
    if ctxt.is_some() {
        assert_eq!(
            c.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
            ctxt.unwrap().iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
        );
    }
}

#[test]
fn test_enc_dec() {
    let key = Key::random();
    let iv = Nonce::random();
    let m = Bytes::random(40);
    enc_dec_test(m, key, iv, U32(0), None);
}

#[test]
fn test_kat1() {
    let msg = Bytes::from_array(&[
        U8(0x6b), U8(0xc1), U8(0xbe), U8(0xe2), U8(0x2e), U8(0x40), U8(0x9f), U8(0x96),
        U8(0xe9), U8(0x3d), U8(0x7e), U8(0x11), U8(0x73), U8(0x93), U8(0x17), U8(0x2a),
    ]);
    let key = Key([
        U8(0x2b), U8(0x7e), U8(0x15), U8(0x16), U8(0x28), U8(0xae), U8(0xd2), U8(0xa6),
        U8(0xab), U8(0xf7), U8(0x15), U8(0x88), U8(0x09), U8(0xcf), U8(0x4f), U8(0x3c),
    ]);
    let nonce = Nonce([
        U8(0xf0), U8(0xf1), U8(0xf2), U8(0xf3), U8(0xf4), U8(0xf5), U8(0xf6), U8(0xf7),
        U8(0xf8), U8(0xf9), U8(0xfa), U8(0xfb),
    ]);
    let ctr = U32(0xfcfdfeff);
    let ctxt = Bytes::from_array(&[
        U8(0x87), U8(0x4d), U8(0x61), U8(0x91), U8(0xb6), U8(0x20), U8(0xe3), U8(0x26),
        U8(0x1b), U8(0xef), U8(0x68), U8(0x64), U8(0x99), U8(0x0d), U8(0xb6), U8(0xce),
    ]);
    enc_dec_test(msg, key, nonce, ctr, Some(ctxt));
}

#[test]
fn test_kat2() {
    let msg = Bytes::from_array(&[
        U8(0x00), U8(0x01), U8(0x02), U8(0x03), U8(0x04), U8(0x05), U8(0x06), U8(0x07),
        U8(0x08), U8(0x09), U8(0x0A), U8(0x0B), U8(0x0C), U8(0x0D), U8(0x0E), U8(0x0F),
        U8(0x10), U8(0x11), U8(0x12), U8(0x13), U8(0x14), U8(0x15), U8(0x16), U8(0x17),
        U8(0x18), U8(0x19), U8(0x1A), U8(0x1B), U8(0x1C), U8(0x1D), U8(0x1E), U8(0x1F),
    ]);
    let key = Key([
        U8(0x7E), U8(0x24), U8(0x06), U8(0x78), U8(0x17), U8(0xFA), U8(0xE0), U8(0xD7),
        U8(0x43), U8(0xD6), U8(0xCE), U8(0x1F), U8(0x32), U8(0x53), U8(0x91), U8(0x63),
    ]);
    let nonce = Nonce([
        U8(0x00), U8(0x6C), U8(0xB6), U8(0xDB), U8(0xC0), U8(0x54), U8(0x3B), U8(0x59),
        U8(0xDA), U8(0x48), U8(0xD9), U8(0x0B),
    ]);
    let ctr = 0x00000001;
    let ctxt = Bytes::from_array(&[
        U8(0x51), U8(0x04), U8(0xA1), U8(0x06), U8(0x16), U8(0x8A), U8(0x72), U8(0xD9),
        U8(0x79), U8(0x0D), U8(0x41), U8(0xEE), U8(0x8E), U8(0xDA), U8(0xD3), U8(0x88),
        U8(0xEB), U8(0x2E), U8(0x1E), U8(0xFC), U8(0x46), U8(0xDA), U8(0x57), U8(0xC8),
        U8(0xFC), U8(0xE6), U8(0x30), U8(0xDF), U8(0x91), U8(0x41), U8(0xBE), U8(0x28),
    ]);
    enc_dec_test(msg, key, nonce, U32(ctr), Some(ctxt));
}
