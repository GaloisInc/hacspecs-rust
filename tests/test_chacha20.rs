extern crate hacspec;
use hacspec::*;
hacspec_imports!();

extern crate hacspecs;
use hacspecs::chacha20::*;

#[test]
fn test_quarter_round() {
    let mut state = State([
        U32(0x879531e0), U32(0xc5ecf37d), U32(0x516461b1), U32(0xc9a62f8a),
        U32(0x44c20ef3), U32(0x3390af7f), U32(0xd9fc690b), U32(0x2a5f714c),
        U32(0x53372767), U32(0xb00a5631), U32(0x974c541a), U32(0x359e9963),
        U32(0x5c971061), U32(0x3d631689), U32(0x2098d9d6), U32(0x91dbd320),
    ]);
    let expected_state = State([
        U32(0x879531e0), U32(0xc5ecf37d), U32(0xbdb886dc), U32(0xc9a62f8a),
        U32(0x44c20ef3), U32(0x3390af7f), U32(0xd9fc690b), U32(0xcfacafd2),
        U32(0xe46bea80), U32(0xb00a5631), U32(0x974c541a), U32(0x359e9963),
        U32(0x5c971061), U32(0xccc07c79), U32(0x2098d9d6), U32(0x91dbd320),
    ]);
    state = quarter_round(2, 7, 8, 13, state);
    assert_eq!(
        state.iter().map(|x| U32::declassify(*x)).collect::<Vec<_>>(),
        expected_state.iter().map(|x| U32::declassify(*x)).collect::<Vec<_>>()
    );
}

#[test]
fn test_block() {
    let key = Key([
        U8(0x00), U8(0x01), U8(0x02), U8(0x03), U8(0x04), U8(0x05), U8(0x06), U8(0x07),
        U8(0x08), U8(0x09), U8(0x0a), U8(0x0b), U8(0x0c), U8(0x0d), U8(0x0e), U8(0x0f),
        U8(0x10), U8(0x11), U8(0x12), U8(0x13), U8(0x14), U8(0x15), U8(0x16), U8(0x17),
        U8(0x18), U8(0x19), U8(0x1a), U8(0x1b), U8(0x1c), U8(0x1d), U8(0x1e), U8(0x1f),
    ]);
    let iv = IV([
        U8(0x00), U8(0x00), U8(0x00), U8(0x09), U8(0x00), U8(0x00),
        U8(0x00), U8(0x4a), U8(0x00), U8(0x00), U8(0x00), U8(0x00),
    ]);
    let ctr = U32(1);
    let state = block_init(key, ctr, iv);
    let expected_state = State([
        U32(0x61707865), U32(0x3320646e), U32(0x79622d32), U32(0x6b206574),
        U32(0x03020100), U32(0x07060504), U32(0x0b0a0908), U32(0x0f0e0d0c),
        U32(0x13121110), U32(0x17161514), U32(0x1b1a1918), U32(0x1f1e1d1c),
        U32(0x00000001), U32(0x09000000), U32(0x4a000000), U32(0x00000000),
    ]);
    assert_eq!(
        state.iter().map(|x| U32::declassify(*x)).collect::<Vec<_>>(),
        expected_state.iter().map(|x| U32::declassify(*x)).collect::<Vec<_>>()
    );

    let state = block_inner(key, ctr, iv);
    let expected_state = State([
        U32(0xe4e7f110), U32(0x15593bd1), U32(0x1fdd0f50), U32(0xc47120a3),
        U32(0xc7f4d1c7), U32(0x0368c033), U32(0x9aaa2204), U32(0x4e6cd4c3),
        U32(0x466482d2), U32(0x09aa9f07), U32(0x05d7c214), U32(0xa2028bd9),
        U32(0xd19c12b5), U32(0xb94e16de), U32(0xe883d0cb), U32(0x4e3c50a2),
    ]);
    assert_eq!(
        state.iter().map(|x| U32::declassify(*x)).collect::<Vec<_>>(),
        expected_state.iter().map(|x| U32::declassify(*x)).collect::<Vec<_>>()
    );

    let expected_serialised = [
        U8(0x10), U8(0xf1), U8(0xe7), U8(0xe4), U8(0xd1), U8(0x3b), U8(0x59), U8(0x15),
        U8(0x50), U8(0x0f), U8(0xdd), U8(0x1f), U8(0xa3), U8(0x20), U8(0x71), U8(0xc4),
        U8(0xc7), U8(0xd1), U8(0xf4), U8(0xc7), U8(0x33), U8(0xc0), U8(0x68), U8(0x03),
        U8(0x04), U8(0x22), U8(0xaa), U8(0x9a), U8(0xc3), U8(0xd4), U8(0x6c), U8(0x4e),
        U8(0xd2), U8(0x82), U8(0x64), U8(0x46), U8(0x07), U8(0x9f), U8(0xaa), U8(0x09),
        U8(0x14), U8(0xc2), U8(0xd7), U8(0x05), U8(0xd9), U8(0x8b), U8(0x02), U8(0xa2),
        U8(0xb5), U8(0x12), U8(0x9c), U8(0xd1), U8(0xde), U8(0x16), U8(0x4e), U8(0xb9),
        U8(0xcb), U8(0xd0), U8(0x83), U8(0xe8), U8(0xa2), U8(0x50), U8(0x3c), U8(0x4e),
    ];
    let serialised = state_to_bytes(state);
    println!("{:?}", serialised.len());
    assert_eq!(
        serialised.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        expected_serialised.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
}

fn enc_dec_test(m: Bytes, key: Key, iv: IV) {
    let c = chacha(key, iv, m.clone()).unwrap();
    let m_dec = chacha(key, iv, c).unwrap();
    assert_eq!(
        m.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        m_dec.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
}

fn kat_test(m: Bytes, key: Key, iv: IV, exp_cipher: Bytes, valid: bool) {
    let enc = chacha(key, iv, m.clone());
    assert!(enc.is_ok() == valid);
    if !valid {
        return;
    }
    let c = enc.unwrap();
    assert_eq!(
        exp_cipher.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        c.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
    let m_dec = chacha(key, iv, c).unwrap();
    assert_eq!(
        m.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>(),
        m_dec.iter().map(|x| U8::declassify(*x)).collect::<Vec<_>>()
    );
}

#[test]
fn test_enc_dec() {
    let key = Key::random();
    let iv = IV::random();
    let m = Bytes::random(40);
    enc_dec_test(m, key, iv);
}

#[test]
fn test_kat() {
    let key = Key([
        U8(0x80), U8(0x81), U8(0x82), U8(0x83), U8(0x84), U8(0x85), U8(0x86), U8(0x87),
        U8(0x88), U8(0x89), U8(0x8a), U8(0x8b), U8(0x8c), U8(0x8d), U8(0x8e), U8(0x8f),
        U8(0x90), U8(0x91), U8(0x92), U8(0x93), U8(0x94), U8(0x95), U8(0x96), U8(0x97),
        U8(0x98), U8(0x99), U8(0x9a), U8(0x9b), U8(0x9c), U8(0x9d), U8(0x9e), U8(0x9f),
    ]);
    let iv = IV([
        U8(0x07), U8(0x00), U8(0x00), U8(0x00), U8(0x40), U8(0x41),
        U8(0x42), U8(0x43), U8(0x44), U8(0x45), U8(0x46), U8(0x47),
    ]);
    let m = Bytes::from_array(&[
        U8(0x4c), U8(0x61), U8(0x64), U8(0x69), U8(0x65), U8(0x73), U8(0x20), U8(0x61),
        U8(0x6e), U8(0x64), U8(0x20), U8(0x47), U8(0x65), U8(0x6e), U8(0x74), U8(0x6c),
        U8(0x65), U8(0x6d), U8(0x65), U8(0x6e), U8(0x20), U8(0x6f), U8(0x66), U8(0x20),
        U8(0x74), U8(0x68), U8(0x65), U8(0x20), U8(0x63), U8(0x6c), U8(0x61), U8(0x73),
        U8(0x73), U8(0x20), U8(0x6f), U8(0x66), U8(0x20), U8(0x27), U8(0x39), U8(0x39),
        U8(0x3a), U8(0x20), U8(0x49), U8(0x66), U8(0x20), U8(0x49), U8(0x20), U8(0x63),
        U8(0x6f), U8(0x75), U8(0x6c), U8(0x64), U8(0x20), U8(0x6f), U8(0x66), U8(0x66),
        U8(0x65), U8(0x72), U8(0x20), U8(0x79), U8(0x6f), U8(0x75), U8(0x20), U8(0x6f),
        U8(0x6e), U8(0x6c), U8(0x79), U8(0x20), U8(0x6f), U8(0x6e), U8(0x65), U8(0x20),
        U8(0x74), U8(0x69), U8(0x70), U8(0x20), U8(0x66), U8(0x6f), U8(0x72), U8(0x20),
        U8(0x74), U8(0x68), U8(0x65), U8(0x20), U8(0x66), U8(0x75), U8(0x74), U8(0x75),
        U8(0x72), U8(0x65), U8(0x2c), U8(0x20), U8(0x73), U8(0x75), U8(0x6e), U8(0x73),
        U8(0x63), U8(0x72), U8(0x65), U8(0x65), U8(0x6e), U8(0x20), U8(0x77), U8(0x6f),
        U8(0x75), U8(0x6c), U8(0x64), U8(0x20), U8(0x62), U8(0x65), U8(0x20), U8(0x69),
        U8(0x74), U8(0x2e),
    ]);
    let exp_cipher = Bytes::from_array(&[
        U8(0xd3), U8(0x1a), U8(0x8d), U8(0x34), U8(0x64), U8(0x8e), U8(0x60), U8(0xdb),
        U8(0x7b), U8(0x86), U8(0xaf), U8(0xbc), U8(0x53), U8(0xef), U8(0x7e), U8(0xc2),
        U8(0xa4), U8(0xad), U8(0xed), U8(0x51), U8(0x29), U8(0x6e), U8(0x08), U8(0xfe),
        U8(0xa9), U8(0xe2), U8(0xb5), U8(0xa7), U8(0x36), U8(0xee), U8(0x62), U8(0xd6),
        U8(0x3d), U8(0xbe), U8(0xa4), U8(0x5e), U8(0x8c), U8(0xa9), U8(0x67), U8(0x12),
        U8(0x82), U8(0xfa), U8(0xfb), U8(0x69), U8(0xda), U8(0x92), U8(0x72), U8(0x8b),
        U8(0x1a), U8(0x71), U8(0xde), U8(0x0a), U8(0x9e), U8(0x06), U8(0x0b), U8(0x29),
        U8(0x05), U8(0xd6), U8(0xa5), U8(0xb6), U8(0x7e), U8(0xcd), U8(0x3b), U8(0x36),
        U8(0x92), U8(0xdd), U8(0xbd), U8(0x7f), U8(0x2d), U8(0x77), U8(0x8b), U8(0x8c),
        U8(0x98), U8(0x03), U8(0xae), U8(0xe3), U8(0x28), U8(0x09), U8(0x1b), U8(0x58),
        U8(0xfa), U8(0xb3), U8(0x24), U8(0xe4), U8(0xfa), U8(0xd6), U8(0x75), U8(0x94),
        U8(0x55), U8(0x85), U8(0x80), U8(0x8b), U8(0x48), U8(0x31), U8(0xd7), U8(0xbc),
        U8(0x3f), U8(0xf4), U8(0xde), U8(0xf0), U8(0x8e), U8(0x4b), U8(0x7a), U8(0x9d),
        U8(0xe5), U8(0x76), U8(0xd2), U8(0x65), U8(0x86), U8(0xce), U8(0xc6), U8(0x4b),
        U8(0x61), U8(0x16),
    ]);
    kat_test(m, key, iv, exp_cipher, true);
}
